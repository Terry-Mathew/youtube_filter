TASK_009_001: Research and setup transcript extraction library

## Overview
Evaluate and integrate youtube.js library for client-side transcript extraction from YouTube videos using the InnerTube API.

## Objectives
- Install and configure youtube.js (youtubei.js) library
- Set up TypeScript integration and type definitions
- Create basic transcript extraction proof of concept
- Establish error handling and rate limiting foundation
- Validate library compatibility with existing architecture

## Dependencies
- TASK_007 (YouTube API integration)

## Files to Modify
- package.json
- src/lib/transcript-extractor.ts
- src/types/transcript.ts

## Implementation Details

### 1. Library Installation and Setup

```bash
# Install youtube.js library
npm install youtubei.js

# Install additional types if needed
npm install --save-dev @types/node
```

### 2. Package.json Configuration

```json
{
  "dependencies": {
    "youtubei.js": "^10.5.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  }
}
```

### 3. Basic Transcript Extractor Setup

```typescript
// src/lib/transcript-extractor.ts
import { Innertube, YT } from 'youtubei.js';
import type { 
  YouTubeVideoId, 
  TranscriptSegment, 
  TranscriptLanguage,
  TranscriptQuality 
} from '../types/transcript';

export interface TranscriptExtractionOptions {
  language?: string;
  fallbackLanguages?: string[];
  includeTimestamps?: boolean;
  maxRetries?: number;
}

export interface RawTranscriptData {
  videoId: YouTubeVideoId;
  language: string;
  isAutoGenerated: boolean;
  segments: Array<{
    start: number;
    end: number;
    text: string;
  }>;
  source: 'youtube-captions' | 'youtube-transcript';
}

export class YouTubeTranscriptExtractor {
  private innertube: Innertube | null = null;
  private isInitialized = false;
  private initializationPromise: Promise<void> | null = null;

  constructor() {
    this.initializationPromise = this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      this.innertube = await Innertube.create({
        cache: new UniversalCache(false),
        debug: process.env.NODE_ENV === 'development'
      });
      this.isInitialized = true;
    } catch (error) {
      console.error('Failed to initialize YouTube.js:', error);
      throw new Error('Could not initialize transcript extractor');
    }
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.isInitialized && this.initializationPromise) {
      await this.initializationPromise;
    }
    if (!this.innertube) {
      throw new Error('YouTube.js client not initialized');
    }
  }

  async extractTranscript(
    videoId: YouTubeVideoId, 
    options: TranscriptExtractionOptions = {}
  ): Promise<RawTranscriptData | null> {
    await this.ensureInitialized();
    
    try {
      const videoInfo = await this.innertube!.getInfo(videoId);
      
      if (!videoInfo.captions) {
        console.warn(`No captions available for video: ${videoId}`);
        return null;
      }

      const availableLanguages = this.getAvailableLanguages(videoInfo.captions);
      const selectedLanguage = this.selectBestLanguage(
        availableLanguages, 
        options.language, 
        options.fallbackLanguages
      );

      if (!selectedLanguage) {
        console.warn(`No suitable language found for video: ${videoId}`);
        return null;
      }

      const transcriptData = await this.extractTranscriptData(
        videoInfo, 
        selectedLanguage, 
        options
      );

      return {
        videoId,
        language: selectedLanguage.language,
        isAutoGenerated: selectedLanguage.isAutoGenerated,
        segments: transcriptData,
        source: 'youtube-captions'
      };

    } catch (error) {
      console.error(`Failed to extract transcript for ${videoId}:`, error);
      return null;
    }
  }

  private getAvailableLanguages(captions: any): TranscriptLanguage[] {
    // Implementation will depend on youtube.js API structure
    return [];
  }

  private selectBestLanguage(
    available: TranscriptLanguage[],
    preferred?: string,
    fallbacks?: string[]
  ): TranscriptLanguage | null {
    if (preferred) {
      const match = available.find(lang => lang.language === preferred);
      if (match) return match;
    }

    if (fallbacks) {
      for (const fallback of fallbacks) {
        const match = available.find(lang => lang.language === fallback);
        if (match) return match;
      }
    }

    const english = available.find(lang => 
      lang.language === 'en' || lang.language.startsWith('en-')
    );
    if (english) return english;

    const manual = available.find(lang => !lang.isAutoGenerated);
    if (manual) return manual;

    return available[0] || null;
  }

  private async extractTranscriptData(
    videoInfo: any,
    language: TranscriptLanguage,
    options: TranscriptExtractionOptions
  ): Promise<TranscriptSegment[]> {
    // Placeholder for actual transcript extraction logic
    return [];
  }

  async hasTranscript(videoId: YouTubeVideoId): Promise<boolean> {
    try {
      await this.ensureInitialized();
      const videoInfo = await this.innertube!.getInfo(videoId);
      return !!videoInfo.captions;
    } catch (error) {
      console.error(`Failed to check transcript availability for ${videoId}:`, error);
      return false;
    }
  }

  dispose(): void {
    this.innertube = null;
    this.isInitialized = false;
    this.initializationPromise = null;
  }
}

// Singleton instance
export const transcriptExtractor = new YouTubeTranscriptExtractor();
```

### 4. TypeScript Type Definitions

```typescript
// src/types/transcript.ts
export interface TranscriptLanguage {
  language: string;
  languageName: string;
  isAutoGenerated: boolean;
  isTranslatable: boolean;
}

export interface TranscriptSegment {
  start: number;
  end: number;
  duration: number;
  text: string;
}

export type TranscriptQuality = 'high' | 'medium' | 'low';

export interface TranscriptMetadata {
  videoId: YouTubeVideoId;
  language: string;
  isAutoGenerated: boolean;
  totalDuration: number;
  segmentCount: number;
  quality: TranscriptQuality;
  extractedAt: Date;
  source: 'youtube-captions' | 'youtube-transcript' | 'fallback';
}

export enum TranscriptErrorCode {
  NO_CAPTIONS_AVAILABLE = 'NO_CAPTIONS_AVAILABLE',
  UNSUPPORTED_LANGUAGE = 'UNSUPPORTED_LANGUAGE',
  EXTRACTION_FAILED = 'EXTRACTION_FAILED',
  RATE_LIMITED = 'RATE_LIMITED',
  VIDEO_NOT_FOUND = 'VIDEO_NOT_FOUND',
  INITIALIZATION_FAILED = 'INITIALIZATION_FAILED'
}

export class TranscriptExtractionError extends Error {
  constructor(
    message: string,
    public readonly videoId: YouTubeVideoId,
    public readonly code: TranscriptErrorCode,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'TranscriptExtractionError';
  }
}
```

## Research Notes

### YouTube.js Library Analysis
- **Trust Score**: 9.5/10 with 1798 code snippets
- **Active Development**: Regular updates and maintenance
- **TypeScript Support**: Full TypeScript definitions
- **Client-Side**: Works entirely in browser without CORS issues
- **InnerTube API**: Uses YouTube's private but stable API

### API Capabilities Discovered
- Transcript/caption extraction in multiple languages
- Auto-generated vs manual transcript detection
- Timestamp preservation for segments
- Language selection and fallback support
- Video metadata integration

### Integration Compatibility
- ✅ Works with Vite + React architecture
- ✅ No server-side requirements
- ✅ Compatible with existing YouTube API patterns
- ✅ Supports TypeScript strict mode
- ✅ No additional CORS configuration needed

## Testing Strategy

### Unit Tests
- Library initialization and configuration
- Error handling for various failure scenarios
- Language selection logic
- Basic transcript extraction

### Integration Tests
- Test with real YouTube videos (known good cases)
- Verify TypeScript integration
- Check memory usage and cleanup

### Performance Tests
- Measure extraction time for various video lengths
- Test concurrent extraction limits
- Validate rate limiting implementation

## Acceptance Criteria
- [ ] youtube.js library successfully installed and configured
- [ ] Basic transcript extraction working for test videos
- [ ] TypeScript integration complete with proper types
- [ ] Error handling follows existing patterns
- [ ] Compatible with existing architecture
- [ ] Unit tests passing
- [ ] Performance acceptable (< 5s for typical transcript)
- [ ] Memory usage optimized

## Future Enhancements
- Advanced language detection and selection
- Transcript quality scoring algorithms
- Batch extraction capabilities
- Advanced error recovery strategies
- Performance monitoring and analytics
